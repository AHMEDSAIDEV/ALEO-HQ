---
id: language
title: Aleo Instructions Language Guide
sidebar_label: Language
---

### Statically Typed
Aleo instructions is a **statically typed language**, which means we must know the type of each variable before executing a circuit.

### Explicit Types Required
There is no `undefined` or `null` value in Aleo instructions. When assigning a new variable, **the type of the value must be explicitly stated**.

### Pass by Value
Expressions in Aleo instructions are always **passed by value**, which means their values are always copied when they are used as function inputs or in right sides of assignments.

### Register based
There are no variable names in Aleo instructions. 
All variables are stored in registers denoted `rX` where `X` is a non-negative whole number starting from 0 `r0, r1, r2, etc.`.

## Data Types and Values

### Booleans
Aleo instructions supports the traditional `true` or `false` boolean values. The explicit `boolean` type for booleans in statements is required.

```aleo
function main:
    input r0: boolean.private;
```

### Integers
Aleo instructions supports signed integer types `i8`, `i16`, `i32`, `i64`, `i128`
and unsigned integer types `u8`, `u16`, `u32`, `u64`, `u128`.

```aleo
function main:
    input r0: u8.public;
```

:::info
Higher bit length integers generate more constraints in the circuit, which can slow down computation time.
:::

### Field Elements

Aleo instructions supports the `field` type for the base field elements of the elliptic curve.
These are unsigned integers below the modulus of the base field.
```aleo
function main:
    input r0: field.private;
```

### Group Elements
The set of affine points on the elliptic curve passed into the Aleo instructions compiler forms a group.
Leo supports a subgroup of this group, generated by a generator point, as a primitive data type.
Group elements are special since their values can be defined from the x-coordinate of a coordinate pair, such as
`1group`. The group type keyword `group` must be used when specifying a group value.

```aleo
function main:
    input r0: group.private;
```

### Scalar Elements
Aleo instructions supports the `scalar` type for scalar field elements of the elliptic curve subgroup.
These are unsigned integers below the modulus of the scalar field.
```aleo
function main:
    input r0: scalar.private;
```

### Addresses

Addresses are defined to enable compiler-optimized routines for parsing and operating over addresses.

```aleo
function main:
    input r0: address.private;
```

## Layout of an Aleo Program

An Aleo program contains declarations of a [Program ID](#programid), [Imports](#import), [Functions](#function), [Closures](#closure), [Structs](#struct), [Records](#record),
[Mappings](#mapping), and [Finalize](#finalize). Ordering is only enforced for imports which must be at the top of file.
Declarations are locally accessible within a program file.
If you need a declaration from another program file, you must import it.

### Program ID

A program ID is declared as `{name}.{network}`.  
Currently, `aleo` is the only supported `network` domain.

```aleo showLineNumbers
program hello.aleo;
```

### Import

An import is declared as `import {ProgramID};`.  
Imports fetch other declarations by their program ID and bring them into the current file scope.
You can import dependencies that are downloaded to the `imports` directory.

```aleo showLineNumbers
import foo.aleo; // Import the `foo.aleo` program into the `hello.aleo` program.

program hello.aleo;
```

### Function

A function is declared as `function {name}:`.  
Functions contain instructions that can compute values.
Functions must be in a program's current scope to be called.

```aleo showLineNumbers
function foo:
    input r0 as field.public;
    input r1 as field.private;
    add r0 r1 into r2;
    output r2 as field.private;
```

#### Function Inputs

A function input is declared as `input {register} as {type}.{visibility};`.  
Function inputs must be declared just after the function name declaration.

```aleo showLineNumbers
// The function `foo` takes a single input `r0` with type `field` and visibility `public`.
function foo:
    input r0 as field.public; 
```

#### Function Outputs

A function output is declared as `output {register} as {type}.{visibility};`.  
Function outputs must be declared at the end of the function definition.

```aleo showLineNumbers
...
    output r0 as field.public;
```

#### Call a Function
In the Aleo protocol, calling a function creates a transition that can consume and produce records on-chain.
Use the `aleo run` CLI command to pass inputs to a function and execute the program.  
In Testnet3, program functions cannot call other internal program functions.
If you would like to develop "helper functions" that are called internally within a program, try writing a `closure`.

#### Call an Imported Function
Aleo programs can externally call other Aleo programs using the `call {program}/{function} {register} into {register}` instruction.
```aleo 
import foo.aleo;

program bar.aleo;

function call_external:
    input r0 as u64.private;
    call foo.aleo/baz r0 into r1; // Externally call function `baz` in foo.aleo with argument `r0` and store the result in `r1`.
    output r1;
```

### Closure

A closure is declared as `closure {name}:`.  
Closures contain instructions that can compute values.
Closures are helper functions that cannot be executed directly. Closures may be called by other functions.

```aleo showLineNumbers
closure foo:
    input r0 as field;
    input r1 as field;
    add r0 r1 into r2;
    output r2 as field;
```

#### Call a Closure
Aleo programs can internally call other Aleo closures using the `call {name} {register} into {register}` instruction.
```aleo 
program bar.aleo;

function call_internal:
    input r0 as u64.private;
    call foo r0 into r1; // Internally call closure `foo` with argument `r0` and store the result in `r1`.
    output r1;
```


### Struct

A struct is a data type declared as `struct {name}:`.  
Structs contain component declarations `{name} as {type}`.

```aleo showLineNumbers
struct array3:
    a0 as u32;
    a1 as u32;
    a2 as u32;
```

To instantiate a `struct` in a program use the `cast` instruction.
```aleo showLineNumbers
function new_array3:
    input r0 as u32.private;
    input r1 as u32.private;
    input r2 as u32.private;
    cast r0 r1 r2 into r3 as array3;
    output r3;
```

### Record

A [record](../concepts/02_records.md) type is declared as `record {name}:`.  
Records contain component declarations `{name} as {type}.{visibility};`.  
Record data structures must contain the `owner` and `gates` declarations as shown below.  
When passing a record as input to a program function the `_nonce as group.{visibility}` declaration is also required.

```aleo showLineNumbers
record token:
    // The token owner.
    owner as address.private;
    // The Aleo balance (in gates).
    gates as u64.private;
    // The token amount.
    amount as u64.private;
```

To instantiate a `record` in a program use the `cast` instruction.
```aleo showLineNumbers
function new_token:
    input r0 as address.private;
    input r1 as u64.private;
    input r2 as u64.private;
    cast r0 r1 r2 into r3 as token.record;
    output r3;
```

### Mapping

A mapping is declared as `mapping {name}:`.  
Mappings contain key-value pairs.
Mappings must be defined within a program scope.
Mappings are stored publicly on-chain. It is not possible to store data privately in a mapping.

```aleo showLineNumbers
// On-chain storage of an `account` map, with `owner` as the key,
// and `amount` as the value.
mapping account:
    // The token owner.
    key owner as address.public;
    // The token amount.
    value amount as u64.public;
```

#### Increment and Decrement
An increment instruction has the form `increment {name}[{register}] by {register};`.  
A decrement instruction has the form `decrement {name}[{register}] by {register};`.  
These instructions are used in [finalize](#finalize).

```aleo showLineNumbers
finalize transfer_public:
    // Input the token sender.
    input r0 as address.public;
    // Input the token receiver.
    input r1 as address.public;
    // Input the token amount.
    input r2 as u64.public;

    // Decrements `account[r0]` by `r2`.
    // If `account[r0]` does not exist, it will be created.
    // If `account[r0] - r2` underflows, `transfer_public` is reverted.
    decrement account[r0] by r2;

    // Increments `account[r1]` by `r2`.
    // If `account[r1]` does not exist, it will be created.
    // If `account[r1] + r2` overflows, `transfer_public` is reverted.
    increment account[r1] by r2;
```

### Finalize

A finalize is declared as `finalize {name}:`.  
A finalize must immediately follow a [function](#function), and must have the same name;
it is associated with the function and is executed on chain,
after the zero-knowledge proof of the execution of the associated function is verified;
a finalize *finalizes* a function on chain.  
Upon success of the finalize function, the program logic is executed.  
Upon failure of the finalize function, the program logic is reverted.  

```aleo showLineNumbers
// The function `transfer_public_to_private` turns a specified token amount
// from `account` into a token record for the specified receiver.
// 
// This function preserves privacy for the receiver's record, however
// it publicly reveals the caller and the specified token amount.
function transfer_public_to_private:
    // Input the token receiver.
    input r0 as address.public;
    // Input the token amount.
    input r1 as u64.public;

    // Produces a token record for the token receiver.
    cast r0 0u64 r1 into r2 as token.record;

    // Output the receiver's record.
    output r2 as token.record;

    // Decrement the token amount of the caller publicly.
    finalize self.caller r1;

finalize transfer_public_to_private:
    // Input the token owner.
    input r0 as address.public;
    // Input the token amount.
    input r1 as u64.public;

    // Decrements `account[r0]` by `r1`.
    // If `account[r0]` does not exist, it will be created.
    // If `account[r0] - r1` underflows, `transfer_public_to_private` is reverted.
    decrement account[r0] by r1;
```

