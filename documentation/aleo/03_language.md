---
id: language
title: Aleo Instructions Language Guide
sidebar_label: Language
---

### Statically Typed
Aleo instructions is a **statically typed language**, which means we must know the type of each variable before executing a circuit.

### Explicit Types Required
There is no `undefined` or `null` value in Aleo instructions. When assigning a new variable, **the type of the value must be explicitly stated**.

### Pass by Value
Expressions in Aleo instructions are always **passed by value**, which means their values are always copied when they are used as function inputs or in right sides of assignments.

### Register based
There are no variable names in Aleo instructions. 
All variables are stored in registers denoted `rX` where `X` is a non-negative whole number starting from 0 `r0, r1, r2, etc.`.

## Data Types and Values

### Booleans
Aleo instructions supports the traditional `true` or `false` boolean values. The explicit `boolean` type for booleans in statements is required.

```aleo
function main:
    input r0: boolean.private;
```

### Integers
Aleo instructions supports signed integer types `i8`, `i16`, `i32`, `i64`, `i128`
and unsigned integer types `u8`, `u16`, `u32`, `u64`, `u128`.

```aleo
function main:
    input r0: u8.public;
```

:::info
Higher bit length integers generate more constraints in the circuit, which can slow down computation time.
:::

### Field Elements

Aleo instructions supports the `field` type for the base field elements of the elliptic curve.
These are unsigned integers below the modulus of the base field.
```aleo
function main:
    input r0: field.private;
```

### Group Elements
The set of affine points on the elliptic curve passed into the Aleo instructions compiler forms a group.
Leo supports a subgroup of this group, generated by a generator point, as a primitive data type.
Group elements are special since their values can be defined from the x-coordinate of a coordinate pair, such as
`1group`. The group type keyword `group` must be used when specifying a group value.

```aleo
function main:
    input r0: group.private;
```

### Scalar Elements
Aleo instructions supports the `scalar` type for scalar field elements of the elliptic curve subgroup.
These are unsigned integers below the modulus of the scalar field.
```aleo
function main:
    input r0: scalar.private;
```

### Addresses

Addresses are defined to enable compiler-optimized routines for parsing and operating over addresses.

```aleo
function main:
    input r0: address.private;
```

## Layout of an Aleo Program

An Aleo program contains declarations of a [Program ID](#programid), [Imports](#import), [Functions](#function), [Closures](#closure), [Structs](#struct), [Records](#record),
[Mappings](#mapping), and [Finalize](#finalize). Ordering is only enforced for imports which must be at the top of file.
Declarations are locally accessible within a program file.
If you need a declaration from another program file, you must import it.

### Program ID

A program ID is declared as `{name}.{network}`.
The first character of a `name` must be lowercase.
`name` can contain lowercase letters, numbers, and underscores.
Currently, `aleo` is the only supported `network` domain.

```aleo showLineNumbers
program hello.aleo; // valid

program Foo.aleo;   // invalid
program baR.aleo;   // invalid
program 0foo.aleo;  // invalid
program 0_foo.aleo; // invalid
program _foo.aleo;  // invalid
```

### Import

An import is declared as `import {ProgramID};`.  
Imports fetch other declarations by their program ID and bring them into the current file scope.
You can import dependencies that are downloaded to the `imports` directory.

```aleo showLineNumbers
import foo.aleo; // Import the `foo.aleo` program into the `hello.aleo` program.

program hello.aleo;
```

### Function

A function is declared as `function {name}:`.  
Functions contain instructions that can compute values.
Functions must be in a program's current scope to be called.

```aleo showLineNumbers
function foo:
    input r0 as field.public;
    input r1 as field.private;
    add r0 r1 into r2;
    output r2 as field.private;
```

#### Function Inputs

A function input is declared as `input {register} as {type}.{visibility};`.  
Function inputs must be declared just after the function name declaration.

```aleo showLineNumbers
// The function `foo` takes a single input `r0` with type `field` and visibility `public`.
function foo:
    input r0 as field.public; 
```

#### Function Outputs

A function output is declared as `output {register} as {type}.{visibility};`.  
Function outputs must be declared at the end of the function definition.

```aleo showLineNumbers
...
    output r0 as field.public;
```

#### Call a Function
In the Aleo protocol, calling a function creates a transition that can consume and produce records on-chain.
Use the `aleo run` CLI command to pass inputs to a function and execute the program.  
In Testnet3, program functions cannot call other internal program functions.
If you would like to develop "helper functions" that are called internally within a program, try writing a `closure`.

#### Call an Imported Function
Aleo programs can externally call other Aleo programs using the `call {program}/{function} {register} into {register}` instruction.
```aleo 
import foo.aleo;

program bar.aleo;

function call_external:
    input r0 as u64.private;
    call foo.aleo/baz r0 into r1; // Externally call function `baz` in foo.aleo with argument `r0` and store the result in `r1`.
    output r1;
```

### Closure

A closure is declared as `closure {name}:`.  
Closures contain instructions that can compute values.
Closures are helper functions that cannot be executed directly. Closures may be called by other functions.

```aleo showLineNumbers
closure foo:
    input r0 as field;
    input r1 as field;
    add r0 r1 into r2;
    output r2 as field;
```

#### Call a Closure
Aleo programs can internally call other Aleo closures using the `call {name} {register} into {register}` instruction.
```aleo 
program bar.aleo;

function call_internal:
    input r0 as u64.private;
    call foo r0 into r1; // Internally call closure `foo` with argument `r0` and store the result in `r1`.
    output r1;
```


### Struct

A struct is a data type declared as `struct {name}:`.  
Structs contain component declarations `{name} as {type}`.

```aleo showLineNumbers
struct array3:
    a0 as u32;
    a1 as u32;
    a2 as u32;
```

To instantiate a `struct` in a program use the `cast` instruction.
```aleo showLineNumbers
function new_array3:
    input r0 as u32.private;
    input r1 as u32.private;
    input r2 as u32.private;
    cast r0 r1 r2 into r3 as array3;
    output r3;
```

### Record

A [record](../concepts/02_records.md) type is declared as `record {name}:`.  
Records contain component declarations `{name} as {type}.{visibility};`.  
Record data structures must contain the `owner` declaration as shown below.  
When passing a record as input to a program function the `_nonce as group.{visibility}` declaration is also required.

```aleo showLineNumbers
record token:
    // The token owner.
    owner as address.private;
    // The Aleo balance (in microcredits).
    microcredits as u64.private;
    // The token amount.
    amount as u64.private;
```

To instantiate a `record` in a program use the `cast` instruction.
```aleo showLineNumbers
function new_token:
    input r0 as address.private;
    input r1 as u64.private;
    input r2 as u64.private;
    cast r0 r1 r2 into r3 as token.record;
    output r3;
```

### Mapping

A mapping is declared as `mapping {name}:`.  
Mappings contain key-value pairs.
Mappings must be defined within a program scope.
Mappings are stored publicly on-chain. It is not possible to store data privately in a mapping.

```aleo showLineNumbers
// On-chain storage of an `account` map, with `owner` as the key,
// and `amount` as the value.
mapping account:
    // The token owner.
    key owner as address.public;
    // The token amount.
    value amount as u64.public;
```

#### Contains

A contains command that checks if a key exists in a mapping, e.g. `contains accounts[r0] into r1;`.

#### Get

A get command that retrieves a value from a mapping, e.g. `get accounts[r0] into r1;`.

#### Get or Use

A get command that uses the provided default in case of failure, e.g. `get.or_use accounts[r0] r1 into r2;`.

```aleo showLineNumbers
finalize transfer_public:
    // Input the sender.
    input r0 as address.public;
    // Input the receiver.
    input r1 as address.public;
    // Input the amount.
    input r2 as u64.public;
    
    // Decrements `account[r0]` by `r2`.
    // If `account[r0]` does not exist, 0u64 is used.
    // If `account[r0] - r2` underflows, `transfer_public` is reverted.
    get.or_use account[r0] 0u64 into r3;
    sub r3 r2 into r4;
    set r4 into account[r0];
    
    // Increments `account[r1]` by `r2`.
    // If `account[r1]` does not exist, 0u64 is used.
    // If `account[r1] + r2` overflows, `transfer_public` is reverted.
    get.or_use account[r1] 0u64 into r5;
    add r5 r2 into r6;
    set r6 into account[r1];
```

#### Set

A set command that sets a value in a mapping, e.g. `set r0 into accounts[r0];`.

#### Remove

A remove command that removes a key-value pair from a mapping, e.g. `remove accounts[r0];`.



```aleo showLineNumbers

### Finalize

A finalize is declared as `finalize {name}:`.  
A finalize must immediately follow a [function](#function), and must have the same name;
it is associated with the function and is executed on chain,
after the zero-knowledge proof of the execution of the associated function is verified;
a finalize *finalizes* a function on chain.  
Upon success of the finalize function, the program logic is executed.  
Upon failure of the finalize function, the program logic is reverted.  

```aleo showLineNumbers
// The `transfer_public_to_private` function turns a specified amount
// from the mapping `account` into a record for the specified receiver.
//
// This function preserves privacy for the receiver's record, however
// it publicly reveals the sender and the specified amount.
function transfer_public_to_private:
    // Input the receiver.
    input r0 as address.public;
    // Input the amount.
    input r1 as u64.public;
    
    // Construct a record for the receiver.
    cast r0 r1 into r2 as credits.record;
    
    // Output the record of the receiver.
    output r2 as credits.record;
    
    // Decrement the balance of the sender publicly.
    finalize self.caller r1;

finalize transfer_public_to_private:
    // Input the sender.
    input r0 as address.public;
    // Input the amount.
    input r1 as u64.public;
    
    // Retrieve the balance of the sender.
    // If `account[r0]` does not exist, 0u64 is used.
    get.or_use account[r0] 0u64 into r2;
    
    // Decrements `account[r0]` by `r1`.
    // If `r2 - r1` underflows, `trasfer_public_to_private` is reverted.
    sub r2 r1 into r3;
    
    // Updates the balance of the sender.
    set r3 into account[r0];
```

### Commands

The following commands are supported in Aleo Instructions to provide additional program functionality.

#### self.caller
The `self.caller` command returns the address of the caller of the program.  
This can be useful for managing access control to a program.
In the above example, the `transfer_public_to_private` function decrements the balance of the sender publicly using `self.caller`.

#### block.height
The `block.height` command returns the height of the block in which the program is executed (latest block height + 1).
This can be useful for managing time-based access control to a program.
The `block.height` command must be called within a finalize block.

```aleo
assert.eq block.height 100u64;
```

#### rand.chacha

The `rand.chacha` command returns a random number generated by the [ChaCha20 algorithm](http://cr.yp.to/chacha.html).  
This command supports sampling a random `address`, `boolean`, `field`, `group`, `i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`, and `scalar`.  
Up to two additional seeds can be provided to the `rand.chacha` command.  
Currently, only ChaCha20 is supported, however, in the future, other random number generators may be supported.

```aleo
rand.chacha into r0 as field;
rand.chacha r0 into r1 as field;
rand.chacha r0 r1 into r2 as field;
```

#### Hash

Aleo Instructions supports the following syntax for hashing to standard types.
```aleo
hash.bhp256 r0 into r1 as address;
hash.bhp256 r0 into r1 as field;
hash.bhp256 r0 into r1 as group;
hash.bhp256 r0 into r1 as i8;
hash.bhp256 r0 into r1 as i16;
hash.bhp256 r0 into r1 as i32;
hash.bhp256 r0 into r1 as i64;
hash.bhp256 r0 into r1 as i128;
hash.bhp256 r0 into r1 as u8;
hash.bhp256 r0 into r1 as u16;
hash.bhp256 r0 into r1 as u32;
hash.bhp256 r0 into r1 as u64;
hash.bhp256 r0 into r1 as u128;
hash.bhp256 r0 into r1 as scalar;
hash.bhp512 ...;
hash.bhp768 ...;
hash.bhp1024 ...;
hash.ped64 ...;
hash.ped128 ...;
hash.psd2 ...;
hash.psd4 ...;
hash.psd8 ...;
```
Checkout the [Aleo Instructions opcodes](./04_opcodes.md) for a full list of supported hashing algorithms.

#### Commit

Aleo Instructions supports the following syntax for committing to standard types.  
Note that the `commit` command requires any type as the first argument, and a `scalar` as the second argument.
```aleo
commit.bhp256 r0 r1 into r2 as address;
commit.bhp256 r0 r1 into r2 as field;
commit.bhp256 r0 r1 into r2 as group;
commit.bhp512 ...;
commit.bhp768 ...;
commit.bhp1024 ...;
commit.ped64 ...;
commit.ped128 ...;
```
Checkout the [Aleo Instructions opcodes](./04_opcodes.md) for a full list of supported commitment algorithms.

#### position, branch.eq, branch.neq
The `position` command, e.g. `position exit`, indicates a point to branch execution to.  
The `branch.eq` command, e.g. `branch.eq r0 r1 to exit`, which branches execution to the position indicated by `exit` if `r0` and `r1` are equal.  
The `branch.neq` command, e.g. `branch.neq r0 r1 to exit`, which branches execution to the position indicated by `exit` if `r0` and `r1` are not equal.

** Example **
The finalize block exits successfully if the input is 0u8 and fails otherwise.
```aleo
program test_branch.aleo;

function run_test:
    input r0 as u8.public;
    finalize r0;

finalize run_test:
    input r0 as u8.public;
    branch.eq r0 0u8 to exit;
    assert.eq true false;
    position exit;
```